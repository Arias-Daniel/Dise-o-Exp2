<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle - Diseño de Experimentos</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --bg-color: #eef2f3;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: var(--bg-color);
            color: #333;
            user-select: none;
            padding: 20px;
        }

        header { margin-bottom: 20px; text-align: center; }
        h1 { margin: 0; color: var(--primary-color); }

        /* --- DASHBOARD --- */
        .dashboard {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: white;
            padding: 10px 30px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 1px; }
        .stat-value { font-family: 'Roboto Mono', monospace; font-size: 1.4rem; color: var(--primary-color); font-weight: bold; }

        /* --- JUEGO --- */
        #game-container {
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            border: 8px solid #fff;
            border-radius: 4px;
            background-color: #ddd; 
            line-height: 0;
            overflow: hidden; /* Importante para bordes limpios */
        }

        canvas { display: block; cursor: grab; touch-action: none; }
        canvas:active { cursor: grabbing; }

        /* --- MENSAJE VICTORIA --- */
        #win-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .win-card {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            border-top: 8px solid var(--success-color);
            animation: slideUp 0.4s ease-out;
        }

        @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .btn-restart {
            margin-top: 20px;
            padding: 12px 30px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-restart:hover { background: #2980b9; transform: scale(1.05); }

    </style>
</head>
<body>

    <header>
        <h1>Experimento de Armado</h1>
    </header>

    <div class="dashboard">
        <div class="stat-item">
            <span class="stat-label">Tiempo</span>
            <span class="stat-value" id="timer">00:00.00</span>
        </div>
        <div style="width: 1px; background: #ddd; margin: 0 10px;"></div>
        <div class="stat-item">
            <span class="stat-label">Piezas</span>
            <span class="stat-value" id="progress">0 / 64</span>
        </div>
    </div>

    <div id="game-container">
        <canvas id="miCanvas"></canvas>
    </div>

    <div id="win-overlay">
        <div class="win-card">
            <h2 style="color: var(--success-color); margin:0;">¡Excelente!</h2>
            <p>Has completado el experimento.</p>
            <div style="background: #f4f4f4; padding: 10px; border-radius: 8px; margin: 15px 0;">
                <span class="stat-value" id="final-time">00:00.00</span>
            </div>
            <button class="btn-restart" onclick="location.reload()">Nuevo Intento</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('miCanvas');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timer');
        const progressDisplay = document.getElementById('progress');
        const winOverlay = document.getElementById('win-overlay');
        const finalTimeDisplay = document.getElementById('final-time');

        // --- CONFIGURACIÓN ---
        const FILAS = 8;
        const COLUMNAS = 8;
        // ¡IMPORTANTE! Asegúrate que esta ruta sea correcta
        const RUTA_IMAGEN = 'foto.jpg'; 
        const MARGEN_ERROR = 25; // Aumentado ligeramente para facilitar
        
        let img = new Image();
        let piezas = [];
        let anchoPiezaCanvas, altoPiezaCanvas;
        let anchoPiezaImg, altoPiezaImg;
        let piezaSeleccionada = null;
        let tamanoPestana;
        let escalaGlobal; // Variable clave para arreglar la imagen
        
        // Variables Timer
        let startTime = 0;
        let timerInterval;
        let running = false;
        let totalPiezas = FILAS * COLUMNAS;

        img.src = RUTA_IMAGEN;

        img.onload = function() {
            // Ajustar canvas al ancho de pantalla pero respetando proporción
            const maxWidth = Math.min(800, window.innerWidth - 40);
            escalaGlobal = maxWidth / img.width;
            
            canvas.width = maxWidth;
            canvas.height = img.height * escalaGlobal;

            anchoPiezaCanvas = canvas.width / COLUMNAS;
            altoPiezaCanvas = canvas.height / FILAS;
            
            anchoPiezaImg = img.width / COLUMNAS;
            altoPiezaImg = img.height / FILAS;

            // Tamaño de pestaña más pronunciado (25% en lugar de 20%)
            tamanoPestana = Math.min(anchoPiezaCanvas, altoPiezaCanvas) * 0.25;

            inicializarJuego();
        };

        function inicializarJuego() {
            piezas = [];
            let formas = [];

            // Generar formas (Macho/Hembra)
            for(let i=0; i<FILAS; i++) {
                formas[i] = [];
                for(let j=0; j<COLUMNAS; j++) {
                    formas[i][j] = { top: 0, right: 0, bottom: 0, left: 0 };
                }
            }

            for(let i=0; i<FILAS; i++) {
                for(let j=0; j<COLUMNAS; j++) {
                    if(j < COLUMNAS-1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].right = tipo;
                        formas[i][j+1].left = -tipo;
                    }
                    if(i < FILAS-1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].bottom = tipo;
                        formas[i+1][j].top = -tipo;
                    }
                }
            }

            // Crear Piezas
            for(let i=0; i<FILAS; i++) {
                for(let j=0; j<COLUMNAS; j++) {
                    piezas.push({
                        imgX: j * anchoPiezaImg,
                        imgY: i * altoPiezaImg,
                        xCorrecta: j * anchoPiezaCanvas,
                        yCorrecta: i * altoPiezaCanvas,
                        // Posición inicial aleatoria pero dentro del canvas visible
                        x: Math.random() * (canvas.width - anchoPiezaCanvas),
                        y: Math.random() * (canvas.height - altoPiezaCanvas),
                        forma: formas[i][j],
                        bloqueada: false
                    });
                }
            }
            dibujarEscena();
        }

        // --- NUEVA LÓGICA DE DIBUJO DE FORMA (Estilo Puzzle Clásico) ---
        function trazarPieza(ctx, x, y, w, h, forma) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            forma.top !== 0 ? curva(ctx, x, y, x+w, y, forma.top) : ctx.lineTo(x+w, y);
            forma.right !== 0 ? curva(ctx, x+w, y, x+w, y+h, forma.right) : ctx.lineTo(x+w, y+h);
            forma.bottom !== 0 ? curva(ctx, x+w, y+h, x, y+h, forma.bottom) : ctx.lineTo(x, y+h);
            forma.left !== 0 ? curva(ctx, x, y+h, x, y, forma.left) : ctx.lineTo(x, y);
            ctx.closePath();
        }

        function curva(ctx, x1, y1, x2, y2, tipo) {
            // Esta función crea una forma de pieza más "orgánica" y clásica
            const cx = (x1 + x2) / 2;
            const cy = (y1 + y2) / 2;
            const s = tipo * tamanoPestana; 
            
            // Puntos de control para curvas Bezier más suaves (cuello estrecho, cabeza ancha)
            if (Math.abs(x2 - x1) > Math.abs(y2 - y1)) { // Horizontal
                const tercio = (x2 - x1) / 3;
                ctx.bezierCurveTo(x1 + tercio, y1 + s * 0.2, cx - s, y1 + s * 0.2, cx - s * 0.5, y1 + s);
                ctx.bezierCurveTo(cx + s * 0.5, y1 + s, cx + s, y2 + s * 0.2, x2 - tercio, y2 + s * 0.2);
                ctx.lineTo(x2, y2);
            } else { // Vertical
                const tercio = (y2 - y1) / 3;
                ctx.bezierCurveTo(x1 + s * 0.2, y1 + tercio, x1 + s * 0.2, cy - s, x1 + s, cy - s * 0.5);
                ctx.bezierCurveTo(x1 + s, cy + s * 0.5, x2 + s * 0.2, cy + s, x2 + s * 0.2, y2 - tercio);
                ctx.lineTo(x2, y2);
            }
        }

        function dibujarEscena() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fondo guía muy tenue
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            // Dibujar primero las no bloqueadas para que las encajadas queden "al fondo" visualmente
            // O al revés, depende de tu gusto. Aquí dibujamos todas.
            piezas.forEach(p => {
                if(p !== piezaSeleccionada) dibujarPieza(p);
            });

            // La seleccionada siempre encima
            if(piezaSeleccionada) {
                // Sombra para efecto de elevación
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
                dibujarPieza(piezaSeleccionada);
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        }

        // --- CORRECCIÓN DEFINITIVA DE MAPEO DE IMAGEN ---
        function dibujarPieza(p) {
            ctx.save();
            
            // 1. Crear el camino de recorte (la forma del puzzle)
            trazarPieza(ctx, p.x, p.y, anchoPiezaCanvas, altoPiezaCanvas, p.forma);
            ctx.clip();

            // 2. Dibujar la imagen
            // TRUCO MATEMÁTICO: En lugar de calcular recortes, calculamos dónde estaría 
            // la imagen completa si esta pieza estuviera en su lugar correcto, y luego 
            // la movemos según dónde está la pieza ahora.
            
            // Calculamos la posición donde iría la imagen relativa a la pieza
            const imgGlobalX = p.x - (p.imgX * escalaGlobal);
            const imgGlobalY = p.y - (p.imgY * escalaGlobal);

            // Dibujamos la imagen completa (el clip se encarga de mostrar solo lo necesario)
            // Usamos un pequeño margen de seguridad en el recorte origen para optimizar rendimiento
            // pero manteniendo la alineación perfecta de la escala global.
            const margenSeguridad = tamanoPestana * 4; // Margen amplio para cubrir las curvas
            
            // Coordenadas en la imagen original
            const sx = Math.max(0, p.imgX - (margenSeguridad / escalaGlobal));
            const sy = Math.max(0, p.imgY - (margenSeguridad / escalaGlobal));
            const sw = Math.min(img.width - sx, anchoPiezaImg + (margenSeguridad * 2 / escalaGlobal));
            const sh = Math.min(img.height - sy, altoPiezaImg + (margenSeguridad * 2 / escalaGlobal));

            // Coordenadas en el canvas
            const dx = p.x - (p.imgX * escalaGlobal) + (sx * escalaGlobal);
            const dy = p.y - (p.imgY * escalaGlobal) + (sy * escalaGlobal);
            const dw = sw * escalaGlobal;
            const dh = sh * escalaGlobal;

            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);

            ctx.restore();

            // 3. Dibujar borde (Stroke)
            ctx.save();
            trazarPieza(ctx, p.x, p.y, anchoPiezaCanvas, altoPiezaCanvas, p.forma);
            ctx.lineWidth = 2; // Borde un poco más grueso se ve mejor
            
            if (p.bloqueada) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; // Muy sutil si está encajada
                ctx.stroke();
            } else {
                ctx.strokeStyle = "#fff"; // Blanco sólido
                ctx.stroke();
                ctx.strokeStyle = "rgba(0,0,0,0.2)"; // Borde interior oscuro sutil
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            ctx.restore();
        }

        // --- FUNCIONES DE JUEGO (Igual que antes) ---
        function empezarTimer() {
            if(!running) {
                running = true;
                startTime = Date.now();
                timerInterval = setInterval(() => {
                    let delta = Date.now() - startTime;
                    timerDisplay.textContent = formatearTiempo(delta);
                }, 50);
            }
        }

        function detenerTimer() {
            running = false;
            clearInterval(timerInterval);
            let final = formatearTiempo(Date.now() - startTime);
            finalTimeDisplay.textContent = final;
            return final;
        }

        function formatearTiempo(ms) {
            let s = Math.floor(ms / 1000);
            let m = Math.floor(s / 60);
            let cs = Math.floor((ms % 1000) / 10);
            s = s % 60;
            return `${pad(m)}:${pad(s)}.${pad(cs)}`;
        }
        function pad(n) { return n < 10 ? '0'+n : n; }

        function checkVictoria() {
            const encajadas = piezas.filter(p => p.bloqueada).length;
            progressDisplay.textContent = `${encajadas} / ${totalPiezas}`;
            
            if(encajadas === totalPiezas) {
                detenerTimer();
                // Dibujar imagen final limpia
                ctx.clearRect(0,0,canvas.width, canvas.height);
                ctx.drawImage(img, 0,0, canvas.width, canvas.height);
                winOverlay.style.display = 'flex';
            }
        }

        // Eventos Mouse
        canvas.onmousedown = function(e) {
            empezarTimer();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // Recorremos al revés para agarrar primero la que esté "arriba"
            for(let i=piezas.length-1; i>=0; i--) {
                let p = piezas[i];
                if(!p.bloqueada && 
                   mx > p.x && mx < p.x + anchoPiezaCanvas && 
                   my > p.y && my < p.y + altoPiezaCanvas) {
                    
                    piezaSeleccionada = p;
                    piezaSeleccionada.offX = mx - p.x;
                    piezaSeleccionada.offY = my - p.y;
                    
                    // Mover al final del array para que se dibuje última (encima)
                    piezas.splice(i, 1);
                    piezas.push(p);
                    
                    dibujarEscena();
                    return;
                }
            }
        };

        canvas.onmousemove = function(e) {
            if(piezaSeleccionada) {
                const rect = canvas.getBoundingClientRect();
                piezaSeleccionada.x = (e.clientX - rect.left) - piezaSeleccionada.offX;
                piezaSeleccionada.y = (e.clientY - rect.top) - piezaSeleccionada.offY;
                dibujarEscena();
            }
        };

        canvas.onmouseup = function() {
            if(piezaSeleccionada) {
                const dist = Math.hypot(piezaSeleccionada.x - piezaSeleccionada.xCorrecta, piezaSeleccionada.y - piezaSeleccionada.yCorrecta);
                if(dist < MARGEN_ERROR) {
                    piezaSeleccionada.x = piezaSeleccionada.xCorrecta;
                    piezaSeleccionada.y = piezaSeleccionada.yCorrecta;
                    piezaSeleccionada.bloqueada = true;
                    // Efecto de sonido (opcional) o visual
                }
                piezaSeleccionada = null;
                dibujarEscena();
                checkVictoria();
            }
        };

        // Soporte Táctil (Móvil)
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY });
            canvas.dispatchEvent(mouseEvent);
        }, {passive: false});

        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY });
            canvas.dispatchEvent(mouseEvent);
        }, {passive: false});

        canvas.addEventListener('touchend', function(e) {
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

    </script>
</body>
</html>