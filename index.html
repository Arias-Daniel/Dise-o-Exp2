<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle - Diseño de Experimentos</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --bg-color: #eef2f3;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: var(--bg-color);
            color: #333;
            user-select: none;
            padding: 20px;
        }

        header { margin-bottom: 20px; text-align: center; }
        h1 { margin: 0; color: var(--primary-color); }

        /* --- DASHBOARD --- */
        .dashboard {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: white;
            padding: 10px 30px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 1px; }
        .stat-value { font-family: 'Roboto Mono', monospace; font-size: 1.4rem; color: var(--primary-color); font-weight: bold; }

        /* --- JUEGO --- */
        #game-container {
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            border: 8px solid #fff;
            border-radius: 4px;
            background-color: #ddd; 
            line-height: 0;
            overflow: hidden; 
        }

        canvas { display: block; cursor: grab; touch-action: none; }
        canvas:active { cursor: grabbing; }

        /* --- MENSAJE VICTORIA --- */
        #win-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .win-card {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            border-top: 8px solid var(--success-color);
            animation: slideUp 0.4s ease-out;
        }

        @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .btn-restart {
            margin-top: 20px;
            padding: 12px 30px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-restart:hover { background: #2980b9; transform: scale(1.05); }

    </style>
</head>
<body>

    <header>
        <h1>Experimento de Armado</h1>
    </header>

    <div class="dashboard">
        <div class="stat-item">
            <span class="stat-label">Tiempo</span>
            <span class="stat-value" id="timer">00:00.00</span>
        </div>
        <div style="width: 1px; background: #ddd; margin: 0 10px;"></div>
        <div class="stat-item">
            <span class="stat-label">Piezas</span>
            <span class="stat-value" id="progress">0 / 64</span>
        </div>
    </div>

    <div id="game-container">
        <canvas id="miCanvas"></canvas>
    </div>

    <div id="win-overlay">
        <div class="win-card">
            <h2 style="color: var(--success-color); margin:0;">¡Excelente!</h2>
            <p>Has completado el experimento.</p>
            <div style="background: #f4f4f4; padding: 10px; border-radius: 8px; margin: 15px 0;">
                <span class="stat-value" id="final-time">00:00.00</span>
            </div>
            <button class="btn-restart" onclick="location.reload()">Nuevo Intento</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('miCanvas');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timer');
        const progressDisplay = document.getElementById('progress');
        const winOverlay = document.getElementById('win-overlay');
        const finalTimeDisplay = document.getElementById('final-time');

        // --- CONFIGURACIÓN ---
        const FILAS = 8;
        const COLUMNAS = 8;
        const RUTA_IMAGEN = 'foto.jpg'; 
        const MARGEN_ERROR = 35; 
        
        let img = new Image();
        let piezas = [];
        let anchoPiezaCanvas, altoPiezaCanvas;
        let anchoPiezaImg, altoPiezaImg;
        let piezaSeleccionada = null;
        let tamanoPestana;
        let escalaGlobal; 
        
        // Variables Timer
        let startTime = 0;
        let timerInterval;
        let running = false;
        let totalPiezas = FILAS * COLUMNAS;

        img.src = RUTA_IMAGEN;

        img.onload = function() {
            const maxWidth = Math.min(800, window.innerWidth - 40);
            escalaGlobal = maxWidth / img.width;
            
            canvas.width = maxWidth;
            canvas.height = img.height * escalaGlobal;

            anchoPiezaCanvas = canvas.width / COLUMNAS;
            altoPiezaCanvas = canvas.height / FILAS;
            
            anchoPiezaImg = img.width / COLUMNAS;
            altoPiezaImg = img.height / FILAS;

            // Tamaño de la pestaña (la oreja)
            tamanoPestana = Math.min(anchoPiezaCanvas, altoPiezaCanvas) * 0.25;

            inicializarJuego();
        };

        function inicializarJuego() {
            piezas = [];
            let formas = [];

            // Generar formas coincidentes
            for(let i=0; i<FILAS; i++) {
                formas[i] = [];
                for(let j=0; j<COLUMNAS; j++) {
                    formas[i][j] = { top: 0, right: 0, bottom: 0, left: 0 };
                }
            }

            for(let i=0; i<FILAS; i++) {
                for(let j=0; j<COLUMNAS; j++) {
                    if(j < COLUMNAS-1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].right = tipo;
                        formas[i][j+1].left = -tipo;
                    }
                    if(i < FILAS-1) {
                        let tipo = Math.random() > 0.5 ? 1 : -1;
                        formas[i][j].bottom = tipo;
                        formas[i+1][j].top = -tipo;
                    }
                }
            }

            for(let i=0; i<FILAS; i++) {
                for(let j=0; j<COLUMNAS; j++) {
                    piezas.push({
                        imgX: j * anchoPiezaImg,
                        imgY: i * altoPiezaImg,
                        xCorrecta: j * anchoPiezaCanvas,
                        yCorrecta: i * altoPiezaCanvas,
                        x: Math.random() * (canvas.width - anchoPiezaCanvas),
                        y: Math.random() * (canvas.height - altoPiezaCanvas),
                        forma: formas[i][j],
                        bloqueada: false
                    });
                }
            }
            dibujarEscena();
        }

        // --- NUEVA LÓGICA GEOMÉTRICA (SOLUCIÓN A LOS HUECOS) ---
        // Usamos vectores normalizados para garantizar que la curva sea idéntica
        // sin importar si se dibuja de arriba-abajo o abajo-arriba.
        
        function trazarPieza(ctx, x, y, w, h, forma) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            // Top (Izq -> Der)
            dibujarLadoVectorial(ctx, x, y, x + w, y, forma.top);
            // Right (Arr -> Aba)
            dibujarLadoVectorial(ctx, x + w, y, x + w, y + h, forma.right);
            // Bottom (Der -> Izq)
            dibujarLadoVectorial(ctx, x + w, y + h, x, y + h, forma.bottom);
            // Left (Aba -> Arr)
            dibujarLadoVectorial(ctx, x, y + h, x, y, forma.left);
            ctx.closePath();
        }

        function dibujarLadoVectorial(ctx, x1, y1, x2, y2, tipo) {
            if (tipo === 0) {
                ctx.lineTo(x2, y2);
                return;
            }

            // Cálculo vectorial para rotación perfecta
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.hypot(dx, dy);

            // Vector Normal (90 grados hacia afuera del sentido de las agujas del reloj)
            // Esto apunta "hacia afuera" de la pieza.
            const nx = dy / len;
            const ny = -dx / len;

            const s = tipo * tamanoPestana; 

            // Puntos de control basados en porcentajes del lado
            // Esto crea una forma de "Oreja" estándar simétrica
            
            // Curva 1: Salida del cuello
            ctx.bezierCurveTo(
                x1 + dx * 0.2 + nx * s * 0.2, y1 + dy * 0.2 + ny * s * 0.2,
                x1 + dx * 0.2 + nx * s * 1.0, y1 + dy * 0.2 + ny * s * 1.0,
                x1 + dx * 0.35 + nx * s * 1.0, y1 + dy * 0.35 + ny * s * 1.0
            );

            // Curva 2: Cabeza de la pestaña
            ctx.bezierCurveTo(
                x1 + dx * 0.45 + nx * s * 1.0, y1 + dy * 0.45 + ny * s * 1.0,
                x1 + dx * 0.55 + nx * s * 1.0, y1 + dy * 0.55 + ny * s * 1.0,
                x1 + dx * 0.65 + nx * s * 1.0, y1 + dy * 0.65 + ny * s * 1.0
            );

            // Curva 3: Regreso del cuello
            ctx.bezierCurveTo(
                x1 + dx * 0.8 + nx * s * 1.0, y1 + dy * 0.8 + ny * s * 1.0,
                x1 + dx * 0.8 + nx * s * 0.2, y1 + dy * 0.8 + ny * s * 0.2,
                x2, y2
            );
        }

        function dibujarEscena() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            piezas.forEach(p => {
                if(p !== piezaSeleccionada) dibujarPieza(p);
            });

            if(piezaSeleccionada) {
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
                dibujarPieza(piezaSeleccionada);
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        }

        // --- RENDERIZADO AVANZADO ---
        function dibujarPieza(p) {
            ctx.save();
            ctx.translate(p.x, p.y);

            // 1. Recorte (Shape)
            trazarPieza(ctx, 0, 0, anchoPiezaCanvas, altoPiezaCanvas, p.forma);
            ctx.clip();

            // 2. Imagen con Sangrado (Bleed)
            // Un sangrado grande asegura que la imagen cubra toda la pestaña
            const margenSeguridad = Math.max(anchoPiezaCanvas, altoPiezaCanvas) * 0.5;
            const margenImg = margenSeguridad / escalaGlobal;

            let sx = p.imgX - margenImg;
            let sy = p.imgY - margenImg;
            let sw = anchoPiezaImg + (margenImg * 2);
            let sh = altoPiezaImg + (margenImg * 2);

            let dx = -margenSeguridad;
            let dy = -margenSeguridad;
            let dw = anchoPiezaCanvas + (margenSeguridad * 2);
            let dh = altoPiezaCanvas + (margenSeguridad * 2);

            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);

            // 3. Bordes
            trazarPieza(ctx, 0, 0, anchoPiezaCanvas, altoPiezaCanvas, p.forma);
            ctx.lineWidth = 1.5;
            if (p.bloqueada) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
                ctx.stroke();
            } else {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                ctx.stroke();
                ctx.shadowColor = "rgba(0,0,0,0.2)";
                ctx.shadowBlur = 2;
                ctx.stroke();
                ctx.shadowColor = "transparent";
            }

            ctx.restore();
        }

        // --- FUNCIONES DE JUEGO ---
        function empezarTimer() {
            if(!running) {
                running = true;
                startTime = Date.now();
                timerInterval = setInterval(() => {
                    let delta = Date.now() - startTime;
                    timerDisplay.textContent = formatearTiempo(delta);
                }, 50);
            }
        }

        function detenerTimer() {
            running = false;
            clearInterval(timerInterval);
            let final = formatearTiempo(Date.now() - startTime);
            finalTimeDisplay.textContent = final;
            return final;
        }

        function formatearTiempo(ms) {
            let s = Math.floor(ms / 1000);
            let m = Math.floor(s / 60);
            let cs = Math.floor((ms % 1000) / 10);
            s = s % 60;
            return `${pad(m)}:${pad(s)}.${pad(cs)}`;
        }
        function pad(n) { return n < 10 ? '0'+n : n; }

        function checkVictoria() {
            const encajadas = piezas.filter(p => p.bloqueada).length;
            progressDisplay.textContent = `${encajadas} / ${totalPiezas}`;
            
            if(encajadas === totalPiezas) {
                detenerTimer();
                ctx.clearRect(0,0,canvas.width, canvas.height);
                ctx.drawImage(img, 0,0, canvas.width, canvas.height);
                winOverlay.style.display = 'flex';
            }
        }

        // Eventos Mouse
        canvas.onmousedown = function(e) {
            empezarTimer();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            for(let i=piezas.length-1; i>=0; i--) {
                let p = piezas[i];
                if(!p.bloqueada && 
                   mx > p.x && mx < p.x + anchoPiezaCanvas && 
                   my > p.y && my < p.y + altoPiezaCanvas) {
                    
                    piezaSeleccionada = p;
                    piezaSeleccionada.offX = mx - p.x;
                    piezaSeleccionada.offY = my - p.y;
                    
                    piezas.splice(i, 1);
                    piezas.push(p);
                    
                    dibujarEscena();
                    return;
                }
            }
        };

        canvas.onmousemove = function(e) {
            if(piezaSeleccionada) {
                const rect = canvas.getBoundingClientRect();
                piezaSeleccionada.x = (e.clientX - rect.left) - piezaSeleccionada.offX;
                piezaSeleccionada.y = (e.clientY - rect.top) - piezaSeleccionada.offY;
                dibujarEscena();
            }
        };

        canvas.onmouseup = function() {
            if(piezaSeleccionada) {
                const dist = Math.hypot(piezaSeleccionada.x - piezaSeleccionada.xCorrecta, piezaSeleccionada.y - piezaSeleccionada.yCorrecta);
                if(dist < MARGEN_ERROR) {
                    piezaSeleccionada.x = piezaSeleccionada.xCorrecta;
                    piezaSeleccionada.y = piezaSeleccionada.yCorrecta;
                    piezaSeleccionada.bloqueada = true;
                }
                piezaSeleccionada = null;
                dibujarEscena();
                checkVictoria();
            }
        };

        // Soporte Táctil
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY });
            canvas.dispatchEvent(mouseEvent);
        }, {passive: false});

        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY });
            canvas.dispatchEvent(mouseEvent);
        }, {passive: false});

        canvas.addEventListener('touchend', function(e) {
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

    </script>
</body>
</html>